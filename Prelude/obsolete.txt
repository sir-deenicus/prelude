The following are ideas for how to flatten nests that ended up not being a good idea.
If they are needed probably something has already gone wrong.

type WaterfallBuilder() =
    member __.Bind(x, f) =
        match x with
        | Some(x) -> x
        | _ -> f x
    member __.Delay(f) = f()
    member __.Return(x) = x
    member __.ReturnFrom(x) = x

type WaterfallOptionBuilder() =
    member __.Bind(x, f) =
        match x with
        | Some(_) as s -> s
        | _ -> f x
    member __.Delay(f) = f()
    member __.Return(x) = Some x
    member __.ReturnFrom(x) = x
    member __.Zero () = None
///A nested if builder is a maybe modified to work with raw conditional tests
type NestedIfBuilder() =
    member __.Bind(x, f) =
       if x then f x
       else () 
    member __.Delay(f) = f() 
    member __.Zero () = ()     

type NestedIfMaybeBuilder() =
    member __.Bind(x, f) =
       if x then f x
       else None 
    member __.Delay(f) = f()
    member __.Return(x) = Some x
    member __.ReturnFrom(x) = x  
let waterfall = WaterfallBuilder()

let waterfallOption = WaterfallOptionBuilder()

let nestif = NestedIfBuilder()  

let nestifMaybe = NestedIfMaybeBuilder()   

==================

This did not actually work: 

let pegasosInitVec λ size = Array.init size (fun _ -> random.NextDouble()) |> Array.to_unitvector |> Array.map ((*) (1./sqrt λ))

///labels must be in {-1,1}
let pegasosOnlineSVM_Step λ (x:float[]) y weightsXstep =
       let w,step = defaultArg weightsXstep (pegasosInitVec λ x.Length,1.)
       let check = y * Array.dotproduct w x

       let η = 1. / (λ * step)  
       let w_halfstep = Array.map ((*) (1. - η * λ)) w
       if check < 1. then  //wrong
         let scalex = Array.map ((*) y) x   
         for i in 0..w.Length - 1 do
            w_halfstep.[i] <- w_halfstep.[i] + η * scalex.[i]
             
       let scale = min 1. ((1./sqrt λ)/ Array.magnitude w_halfstep)
       (Array.map ((*) scale) w_halfstep, step + 1.), check

============================

Earliest graph implementations that are no longer used.


//open Prelude.Collections
[<AbstractClass>]
type FastGraph<'a when 'a: comparison>() =
    abstract InsertVertex: 'a -> bool
    abstract InsertEdge: 'a * 'a -> (bool * bool) option
    abstract ContainsVertex: 'a -> bool
    abstract EdgeData: Collections.Generic.IDictionary<'a, 'a Hashset>
    abstract ContainsEdge: 'a -> 'a -> bool option
    abstract GetEdges: 'a -> 'a [] option

    member g.Vertices =
        g.EdgeData
        |> Seq.map keyValueToKey
        |> Seq.toArray

    member g.Edges =
        Hashset
            (g.EdgeData
             |> Seq.collect (fun (DictKV(k, v)) ->
                 v
                 |> Seq.map (fun e2 -> lessToLeft (k, e2))
                 |> Seq.toArray)
             |> Seq.toArray)
        |> Seq.toArray

type FastStringGraph() =
    inherit FastGraph<string>()
    let edges = Dict<string,string Hashset>()
    
    override g.InsertVertex(s: string) =
        let contained = edges.ContainsKey s
        if not contained then edges.Add(s,Hashset())
        contained
    
    member g.Remove(v) =
        match (edges.tryFind v) with
        | None -> false
        | Some elist -> 
            for v2 in elist do edges.[v2].Remove(v) |> ignore
            edges.Remove v
    
    override g.EdgeData =
        edges :> Collections.Generic.IDictionary<string,string Hashset>
    
    override g.InsertEdge(v0,v1) =
        maybe {
            let! elist0 = edges.tryFind v0
            let! elist1 = edges.tryFind v1
            let in0 = elist0.Add v1
            let in1 = elist1.Add v0
            return (in0,in1)
        }
    
    override g.ContainsVertex v = edges.ContainsKey v
    override g.ContainsEdge v1 v2 = maybe {let! elist0 = edges.tryFind v1
                                           return (elist0.Contains v2)}
    override g.GetEdges v = maybe {let! elist = edges.tryFind v
                                   return elist |> Seq.toArray}


type FastGraphGeneric<'a when 'a: equality and 'a: comparison>() =
    inherit FastGraph<'a>()
    let edges = Dict<'a,'a Hashset>()
    override g.EdgeData =
        edges :> Collections.Generic.IDictionary<'a,'a Hashset>
    
    override g.InsertVertex(s: 'a) =
        let contained = edges.ContainsKey s
        if not contained then edges.Add(s,Hashset())
        contained
    
    member g.Remove(v: 'a) =
        match (edges.tryFind v) with
        | None -> false
        | Some elist -> 
            for v2 in elist do edges.[v2].Remove(v) |> ignore
            edges.Remove v
    
    override g.InsertEdge(v0,v1) =
        maybe {
            let! elist0 = edges.tryFind v0
            let! elist1 = edges.tryFind v1
            let in0 = elist0.Add v1
            let in1 = elist1.Add v0
            return (in0,in1)
        }
    
    override g.ContainsVertex v = edges.ContainsKey v
    override g.ContainsEdge v1 v2 = maybe {let! elist0 = edges.tryFind v1
                                           return (elist0.Contains v2)}
    override g.GetEdges v = maybe {let! elist = edges.tryFind v
                                   return elist |> Seq.toArray}

///uses integer list for edges, better for Dense graphs.
type FastStringGraphIntIndexed() =
    let vertdata = MutableList<string>()
    let edges = Dict<string,int * int Hashset>()
    
    member g.InsertVertex(s: string) =
        let contained = edges.ContainsKey s
        if not contained then 
            edges.Add(s,(vertdata.Count,Hashset()))
            vertdata.Add s
        contained
    
    member g.InsertEdge(v1,v2) =
        maybe {
            let! i0,elist0 = edges.tryFind v1
            let! i1,elist1 = edges.tryFind v2 
            return (elist0.Add i1, elist1.Add i0)
        }
    
    member g.ContainsVertex v = edges.ContainsKey v

    member g.ContainsEdge v1 v2 = maybe {let! _,elist0 = edges.tryFind v1
                                         let! i1,_ = edges.tryFind v2
                                         return (elist0.Contains i1)}
    member g.GetEdges v =
        maybe {
            let! _,elist = edges.tryFind v
            return elist
                   |> Seq.map(fun i -> vertdata.[i])
                   |> Seq.toArray
        }

////////////////
Binary trees are a useful test ground but not helpful

module BinaryTree =
    let rec depthFirstInsert find node =
        function
        | BinaryTree.Node(n) as t ->
            if find n then 
                BinaryTree.Branch(n, (node, BinaryTree.Empty))
            else t
        | BinaryTree.Empty -> node
        | BinaryTree.Branch(n, (l,BinaryTree.Empty)) when find n ->
            BinaryTree.Branch(n, (l,node))
        | BinaryTree.Branch(n, (BinaryTree.Empty,r)) when find n ->
            BinaryTree.Branch(n, (node,r))
        | BinaryTree.Branch(n, _) when find n ->
            failwith "Already occupied"
        | BinaryTree.Branch(n, (l,r)) -> 
            BinaryTree.Branch(n, (depthFirstInsert find node l, depthFirstInsert find node r))

    let rec depthFirstMap f =
        function
        | BinaryTree.Node(n) -> BinaryTree.Node(f n)
        | BinaryTree.Empty -> BinaryTree.Empty
        | BinaryTree.Branch(n, (l,r)) -> 
            BinaryTree.Branch(f n, (depthFirstMap f l, depthFirstMap f r))

    let rec find f = function 
        | BinaryTree.Node(n) ->
            if f n then [n]
            else []
        | BinaryTree.Empty -> []
        | BinaryTree.Branch(n, (l,r)) ->
            if f n then [n]
            else 
                match find f l with
                | [] -> 
                    match find f r with
                    | [] -> []
                    | path -> n::path
                | path -> n::path

    let rec depthFirstFilter keepChild f =
        function
        | BinaryTree.Node(n) ->
            if f n then BinaryTree.Node(n)
            else BinaryTree.Empty
        | BinaryTree.Empty -> BinaryTree.Empty
        | BinaryTree.Branch(n, (l,r)) as t ->
            if f n then
                if keepChild then t
                else BinaryTree.Node(n)
            else 
                match depthFirstFilter keepChild f l, depthFirstFilter keepChild f r with
                | BinaryTree.Empty, BinaryTree.Empty -> BinaryTree.Empty
                | tree -> BinaryTree.Branch(n, tree)

    let rec toTree = function 
        | BinaryTree.Node n -> Node n
        | BinaryTree.Empty -> Empty
        | BinaryTree.Branch(n, (l,r)) -> 
            Branch(n, [toTree l; toTree r])

////////////
Shortest path on DAG

let shortestPath (order:'a[]) (g:IWeightedGraph<'a,_>) (s:'a) =
    if not g.IsDirected then failwith "Not directed"
    let subpath = Array.skipWhile ((<>) s) order
    let d = Array.map (fun n -> n, Double.MaxValue) subpath |> Dict.ofSeq
    d.[s] <- 0.
    let p = Dict()
    for u in subpath do
        match g.GetWeightedEdges u with 
        | None -> ()
        | Some vs ->
            for (v,w) in vs do 
                if d.[v] > d.[u] + w then
                    d.[v] <- d.[u] + w
                    p.ExpandElseAdd v (fun _ -> u) u
    d, p
