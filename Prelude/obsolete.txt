The following are ideas for how to flatten nests that ended up not being a good idea.
If they are needed probably something has already gone wrong.

type WaterfallBuilder() =
    member __.Bind(x, f) =
        match x with
        | Some(x) -> x
        | _ -> f x
    member __.Delay(f) = f()
    member __.Return(x) = x
    member __.ReturnFrom(x) = x

type WaterfallOptionBuilder() =
    member __.Bind(x, f) =
        match x with
        | Some(_) as s -> s
        | _ -> f x
    member __.Delay(f) = f()
    member __.Return(x) = Some x
    member __.ReturnFrom(x) = x
    member __.Zero () = None
///A nested if builder is a maybe modified to work with raw conditional tests
type NestedIfBuilder() =
    member __.Bind(x, f) =
       if x then f x
       else () 
    member __.Delay(f) = f() 
    member __.Zero () = ()     

type NestedIfMaybeBuilder() =
    member __.Bind(x, f) =
       if x then f x
       else None 
    member __.Delay(f) = f()
    member __.Return(x) = Some x
    member __.ReturnFrom(x) = x  
let waterfall = WaterfallBuilder()

let waterfallOption = WaterfallOptionBuilder()

let nestif = NestedIfBuilder()  

let nestifMaybe = NestedIfMaybeBuilder()   

==================

This did not actually work: 

let pegasosInitVec λ size = Array.init size (fun _ -> random.NextDouble()) |> Array.to_unitvector |> Array.map ((*) (1./sqrt λ))

///labels must be in {-1,1}
let pegasosOnlineSVM_Step λ (x:float[]) y weightsXstep =
       let w,step = defaultArg weightsXstep (pegasosInitVec λ x.Length,1.)
       let check = y * Array.dotproduct w x

       let η = 1. / (λ * step)  
       let w_halfstep = Array.map ((*) (1. - η * λ)) w
       if check < 1. then  //wrong
         let scalex = Array.map ((*) y) x   
         for i in 0..w.Length - 1 do
            w_halfstep.[i] <- w_halfstep.[i] + η * scalex.[i]
             
       let scale = min 1. ((1./sqrt λ)/ Array.magnitude w_halfstep)
       (Array.map ((*) scale) w_halfstep, step + 1.), check

============================

Earliest graph implementations that are no longer used.


//open Prelude.Collections
[<AbstractClass>]
type FastGraph<'a when 'a: comparison>() =
    abstract InsertVertex: 'a -> bool
    abstract InsertEdge: 'a * 'a -> (bool * bool) option
    abstract ContainsVertex: 'a -> bool
    abstract EdgeData: Collections.Generic.IDictionary<'a, 'a Hashset>
    abstract ContainsEdge: 'a -> 'a -> bool option
    abstract GetEdges: 'a -> 'a [] option

    member g.Vertices =
        g.EdgeData
        |> Seq.map keyValueToKey
        |> Seq.toArray

    member g.Edges =
        Hashset
            (g.EdgeData
             |> Seq.collect (fun (DictKV(k, v)) ->
                 v
                 |> Seq.map (fun e2 -> lessToLeft (k, e2))
                 |> Seq.toArray)
             |> Seq.toArray)
        |> Seq.toArray

type FastStringGraph() =
    inherit FastGraph<string>()
    let edges = Dict<string,string Hashset>()
    
    override g.InsertVertex(s: string) =
        let contained = edges.ContainsKey s
        if not contained then edges.Add(s,Hashset())
        contained
    
    member g.Remove(v) =
        match (edges.tryFind v) with
        | None -> false
        | Some elist -> 
            for v2 in elist do edges.[v2].Remove(v) |> ignore
            edges.Remove v
    
    override g.EdgeData =
        edges :> Collections.Generic.IDictionary<string,string Hashset>
    
    override g.InsertEdge(v0,v1) =
        maybe {
            let! elist0 = edges.tryFind v0
            let! elist1 = edges.tryFind v1
            let in0 = elist0.Add v1
            let in1 = elist1.Add v0
            return (in0,in1)
        }
    
    override g.ContainsVertex v = edges.ContainsKey v
    override g.ContainsEdge v1 v2 = maybe {let! elist0 = edges.tryFind v1
                                           return (elist0.Contains v2)}
    override g.GetEdges v = maybe {let! elist = edges.tryFind v
                                   return elist |> Seq.toArray}


type FastGraphGeneric<'a when 'a: equality and 'a: comparison>() =
    inherit FastGraph<'a>()
    let edges = Dict<'a,'a Hashset>()
    override g.EdgeData =
        edges :> Collections.Generic.IDictionary<'a,'a Hashset>
    
    override g.InsertVertex(s: 'a) =
        let contained = edges.ContainsKey s
        if not contained then edges.Add(s,Hashset())
        contained
    
    member g.Remove(v: 'a) =
        match (edges.tryFind v) with
        | None -> false
        | Some elist -> 
            for v2 in elist do edges.[v2].Remove(v) |> ignore
            edges.Remove v
    
    override g.InsertEdge(v0,v1) =
        maybe {
            let! elist0 = edges.tryFind v0
            let! elist1 = edges.tryFind v1
            let in0 = elist0.Add v1
            let in1 = elist1.Add v0
            return (in0,in1)
        }
    
    override g.ContainsVertex v = edges.ContainsKey v
    override g.ContainsEdge v1 v2 = maybe {let! elist0 = edges.tryFind v1
                                           return (elist0.Contains v2)}
    override g.GetEdges v = maybe {let! elist = edges.tryFind v
                                   return elist |> Seq.toArray}

///uses integer list for edges, better for Dense graphs.
type FastStringGraphIntIndexed() =
    let vertdata = MutableList<string>()
    let edges = Dict<string,int * int Hashset>()
    
    member g.InsertVertex(s: string) =
        let contained = edges.ContainsKey s
        if not contained then 
            edges.Add(s,(vertdata.Count,Hashset()))
            vertdata.Add s
        contained
    
    member g.InsertEdge(v1,v2) =
        maybe {
            let! i0,elist0 = edges.tryFind v1
            let! i1,elist1 = edges.tryFind v2 
            return (elist0.Add i1, elist1.Add i0)
        }
    
    member g.ContainsVertex v = edges.ContainsKey v

    member g.ContainsEdge v1 v2 = maybe {let! _,elist0 = edges.tryFind v1
                                         let! i1,_ = edges.tryFind v2
                                         return (elist0.Contains i1)}
    member g.GetEdges v =
        maybe {
            let! _,elist = edges.tryFind v
            return elist
                   |> Seq.map(fun i -> vertdata.[i])
                   |> Seq.toArray
        }