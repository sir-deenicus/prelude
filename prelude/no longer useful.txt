//////////////////////////////////////////2D ARRAYS/////////

let foldRow2D, foldCol2D = 1, 0                     


let inline cIndex ind k i (m:'a [,]) = if ind = 1 then m.[k,i] else m.[i,k]

let arr2DFoldAt r k (m : 'a [,]) f seed = 
        let top = m.GetLength(r)
        let rec fold state = function
                | i when i = top -> state
                | i -> fold (f state (cIndex r k i m)) (i + 1)
        fold seed 0   

let arr2DFoldGen index (m : 'a [,]) f seed =
        let ix , xi = if index = 1 then 0, 1 else 1, 0 // fold by row or fold by column
        let top = m.GetLength(ix)   
        let rec fold state = function | i when i = top -> state 
                                      | i -> fold (arr2DFoldAt xi i m f state) (i+1)
        fold seed 0 

let arr2DFold (m : 'a [,]) f seed = arr2DFoldGen 1 m f seed

let arr2DFoldCol (m : 'a [,]) f seed = arr2DFoldGen 0 m f seed   

let distCov (v1:float[]) (v2:float[]) same = 
    let n = v1.Length
    let nf = float n 
    let denum =  nf ** 2.  
    let distMatrix (v:float[]) = Array2D.init v.Length v.Length (fun k l -> abs (v.[k] - v.[l]))  
    let rowMean (m:float[,]) k = (arr2DFoldAt 1 k m (+) 0.)/nf  
    let colMean (m:float[,]) l = (arr2DFoldAt 0 l m (+) 0.)/nf               
    let matrixMean (m:float[,]) = (arr2DFold m (+) 0.) / denum 

    let centredDist (v:float[]) = 
        let distm = distMatrix v
        let meanoverall = matrixMean distm   
        let C = Array2D.create n n 0.
        Threading.Tasks.Parallel.For(0, n, fun i -> 
                        let curRowMean = rowMean distm i
                        for j in 0..n - 1 do 
                            C.[i,j] <- distm.[i,j] - curRowMean - (colMean distm j) + meanoverall  ) |> ignore
        C
             
    let A,B  = 
            if same then let A2 = centredDist v1 in A2, A2   
            else let AB = [| async {return centredDist v1}
                             async {return centredDist v2} |] |> Async.Parallel |> Async.RunSynchronously 
                 AB.[0], AB.[1]
    let _,_,msum = arr2DFold A (fun (i,j,curSum) value -> let nsum = value * B.[i,j] + curSum  
                                                          if j = n - 1 then i+1, 0,nsum else i, j+1,nsum) (0,0,0.)  
    msum  / denum    

//type Array with 
//   static member pfold func (seed:'b) (array:'a[]) =
//         let grown = ref seed         
//         Parallel.ForEach(array, (fun it -> lock grown (fun () -> grown := (func !grown it)))) |> ignore
//         !grown
       

let lasso h lambda alpha (xs : float [][]) (ys:float[]) ws_ =
    let ws = defaultArg ws_ (Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001))   
    let us = Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)   
    let vs = Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)   
    let rec loop err = function 
        | n when n >= (ys.Length - 1) -> err
        | i -> let nw =  ys.[i] - h(Array.dotproduct xs.[i] ws) 
               for j in 0..(ws.Length - 1) do 
                    us.[j] <- max 0. (us.[j] - alpha * (lambda - nw * xs.[i].[j]))
                    vs.[j] <- max 0. (vs.[j] + alpha * (lambda - nw * xs.[i].[j]))
                    ws.[j] <- us.[j] - vs.[j]
            
               loop nw (i + 1)
    let er = loop Double.MaxValue 0                        
    ws,er
    
let svm alpha l (xs : float [][]) (ys:float[]) ws_ = 
    let ws = defaultArg ws_ (Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)) 
    let rec loop err = function 
        | n when n >= (ys.Length - 1) -> err
        | i -> let dtp = ys.[i] * Array.dotproduct xs.[i] ws   
               for j in 0..(ws.Length - 1) do 
                    ws.[j] <- ws.[j] - (alpha * (l * ws.[j] - if dtp > 1. then 0. else ys.[i] * xs.[i].[j]))
            
               loop dtp (i + 1)
    let er = loop Double.MaxValue 0                        
    ws,er  

let svmClassify w x = match sign (Array.dotproduct x w) with -1 -> 0. | x -> float x

//----
 
let w, e  = Onlinelearning.lasso Onlinelearning.logistic 0.01 1. atrain alabels None
classError w (Onlinelearning.logisticClassify) atest atstlbl

//----

let w, e  = Onlinelearning.svm 0.01 0.1 atrain alabels None
classError w (Onlinelearning.svmClassify) atest atstlbl2

//----

let (c, (w,e)) = iterateLearner 5 (Onlinelearning.logisticRegress 1.) pdata plbl
classError w (Onlinelearning.logisticClassify) ptst ptlbl 
//---------

let w, e  = Onlinelearning.lasso Onlinelearning.logistic 0.1 1. pdata plbl None
classError w (Onlinelearning.logisticClassify) ptst ptlbl
 
let w, e  = Onlinelearning.svm 0.1 1. pdata plbl None
classError w (svmClassify) ptst ptlbl
ptst |> Array.map (svmClassify w)