//////////////////////////////////////////2D ARRAYS/////////

module Tuple =
  let toArray5 (a,b,c,d,e) = [|a;b;c;d;e|]

let foldRow2D, foldCol2D = 1, 0                     


let inline cIndex ind k i (m:'a [,]) = if ind = 1 then m.[k,i] else m.[i,k]

let arr2DFoldAt r k (m : 'a [,]) f seed = 
        let top = m.GetLength(r)
        let rec fold state = function
                | i when i = top -> state
                | i -> fold (f state (cIndex r k i m)) (i + 1)
        fold seed 0   

let arr2DFoldGen index (m : 'a [,]) f seed =
        let ix , xi = if index = 1 then 0, 1 else 1, 0 // fold by row or fold by column
        let top = m.GetLength(ix)   
        let rec fold state = function | i when i = top -> state 
                                      | i -> fold (arr2DFoldAt xi i m f state) (i+1)
        fold seed 0 

let arr2DFold (m : 'a [,]) f seed = arr2DFoldGen 1 m f seed

let arr2DFoldCol (m : 'a [,]) f seed = arr2DFoldGen 0 m f seed   

let distCov (v1:float[]) (v2:float[]) same = 
    let n = v1.Length
    let nf = float n 
    let denum =  nf ** 2.  
    let distMatrix (v:float[]) = Array2D.init v.Length v.Length (fun k l -> abs (v.[k] - v.[l]))  
    let rowMean (m:float[,]) k = (arr2DFoldAt 1 k m (+) 0.)/nf  
    let colMean (m:float[,]) l = (arr2DFoldAt 0 l m (+) 0.)/nf               
    let matrixMean (m:float[,]) = (arr2DFold m (+) 0.) / denum 

    let centredDist (v:float[]) = 
        let distm = distMatrix v
        let meanoverall = matrixMean distm   
        let C = Array2D.create n n 0.
        Threading.Tasks.Parallel.For(0, n, fun i -> 
                        let curRowMean = rowMean distm i
                        for j in 0..n - 1 do 
                            C.[i,j] <- distm.[i,j] - curRowMean - (colMean distm j) + meanoverall  ) |> ignore
        C
             
    let A,B  = 
            if same then let A2 = centredDist v1 in A2, A2   
            else let AB = [| async {return centredDist v1}
                             async {return centredDist v2} |] |> Async.Parallel |> Async.RunSynchronously 
                 AB.[0], AB.[1]
    let _,_,msum = arr2DFold A (fun (i,j,curSum) value -> let nsum = value * B.[i,j] + curSum  
                                                          if j = n - 1 then i+1, 0,nsum else i, j+1,nsum) (0,0,0.)  
    msum  / denum    

//type Array with 
//   static member pfold func (seed:'b) (array:'a[]) =
//         let grown = ref seed         
//         Parallel.ForEach(array, (fun it -> lock grown (fun () -> grown := (func !grown it)))) |> ignore
//         !grown
    
	
let autocomplete take (tri:trie<char,'a>) (fragment:string) =  
  let res = MutableList<string>()
  let rec rundownword ctri curword = 
     if is_terminal ctri then
        res.Add(curword)  
     for (DictKV(letter,children)) in node_map ctri do 
       rundownword children (curword + string letter) 

  let starttri = fragment |> Seq.fold (fun curtrie c -> find_subtrie curtrie c) tri
  rundownword starttri fragment  
  res |> Seq.takeOrMax take |> Seq.toArray
  
 
  static member inline unzip5toList (arr : ('a * 'b * 'c * 'd * 'e )  []) = arr |> Array.fold (fun (l1,l2,l3,l4,l5) (d1,d2,d3,d4,d5) -> d1 :: l1, d2 :: l2 , d3::l3, d4 :: l4, d5 :: l5 ) ([],[],[],[],[])
  static member inline unzip7toList (arr : ('a * 'b * 'c * 'd * 'e * 'f * 'g)  []) = arr |> Array.fold (fun (l1,l2,l3,l4,l5,l6,l7) (d1,d2,d3,d4,d5,d6,d7) -> d1 :: l1, d2 :: l2 , d3::l3, d4 :: l4, d5 :: l5 , d6::l6, d7::l7) ([],[],[],[],[],[],[])
  static member inline collapse7 arr = arr |> Array.Parallel.collect (fun  (d1,d2,d3,d4,d5,d6,d7) -> [|d1;d2;d3;d4;d5;d6;d7|]) 
  static member inline collapse5 arr = arr |> Array.Parallel.collect (fun  (d1,d2,d3,d4,d5) -> [|d1;d2;d3;d4;d5|]) 
    

let lasso h lambda alpha (xs : float [][]) (ys:float[]) ws_ =
    let ws = defaultArg ws_ (Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001))   
    let us = Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)   
    let vs = Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)   
    let rec loop err = function 
        | n when n >= (ys.Length - 1) -> err
        | i -> let nw =  ys.[i] - h(Array.dotproduct xs.[i] ws) 
               for j in 0..(ws.Length - 1) do 
                    us.[j] <- max 0. (us.[j] - alpha * (lambda - nw * xs.[i].[j]))
                    vs.[j] <- max 0. (vs.[j] + alpha * (lambda - nw * xs.[i].[j]))
                    ws.[j] <- us.[j] - vs.[j]
            
               loop nw (i + 1)
    let er = loop Double.MaxValue 0                        
    ws,er
    
let svm alpha l (xs : float [][]) (ys:float[]) ws_ = 
    let ws = defaultArg ws_ (Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)) 
    let rec loop err = function 
        | n when n >= (ys.Length - 1) -> err
        | i -> let dtp = ys.[i] * Array.dotproduct xs.[i] ws   
               for j in 0..(ws.Length - 1) do 
                    ws.[j] <- ws.[j] - (alpha * (l * ws.[j] - if dtp > 1. then 0. else ys.[i] * xs.[i].[j]))
            
               loop dtp (i + 1)
    let er = loop Double.MaxValue 0                        
    ws,er  

let svmClassify w x = match sign (Array.dotproduct x w) with -1 -> 0. | x -> float x

//----
 
let w, e  = Onlinelearning.lasso Onlinelearning.logistic 0.01 1. atrain alabels None
classError w (Onlinelearning.logisticClassify) atest atstlbl

//----

let w, e  = Onlinelearning.svm 0.01 0.1 atrain alabels None
classError w (Onlinelearning.svmClassify) atest atstlbl2

//----

let (c, (w,e)) = iterateLearner 5 (Onlinelearning.logisticRegress 1.) pdata plbl
classError w (Onlinelearning.logisticClassify) ptst ptlbl 
//---------

let w, e  = Onlinelearning.lasso Onlinelearning.logistic 0.1 1. pdata plbl None
classError w (Onlinelearning.logisticClassify) ptst ptlbl
 
let w, e  = Onlinelearning.svm 0.1 1. pdata plbl None
classError w (svmClassify) ptst ptlbl
ptst |> Array.map (svmClassify w)

let kmeans k distfunc (xs : float [][]) ws_ = 
    let ws = defaultArg ws_ ([|for i in 1..k -> i-1, 0., Array.init xs.[0].Length (fun _ -> random.NextDouble() + 0.0001)|])
  
    let rec loop = function 
        | n when n >= (xs.Length - 1) -> ()
        | i ->  let j, nk,bestk = ws |> Array.minBy (third >> distfunc)
                (xs.[i], bestk) ||> Array.iteri2 (fun j x w -> bestk.[j] <- w + 1./(nk + 1.) * (x - w))
                ws.[j] <- (j, nk + 1., bestk)    
              
                loop (i + 1)
    loop 0                        
    ws 
  